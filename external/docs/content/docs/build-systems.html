---
### DO NOT EDIT! Generated by script/update-docs.rb

category: manual
section: documentation
subsection: manual
title: Git - build-systems Documentation
docname: build-systems
version: 2.48.0
latest-changes: 2.48.0
aliases:
- "/docs/build-systems/index.html"
---
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>The build system is the primary way for both developers and system integrators
to interact with the Git project. As such, being easy to use and extend for
those who are not directly developing Git itself is just as important as other
requirements we have on any potential build system.</p>
</div>
<div class="paragraph">
<p>This document outlines the different requirements that we have for the build
system and then compares available build systems using these criteria.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_requirements"><a class="anchor" href="#_requirements"></a>Requirements</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The following subsections present a list of requirements that we have for any
potential build system. Sections are sorted by decreasing priority.</p>
</div>
<div class="sect2">
<h3 id="_platform_support"><a class="anchor" href="#_platform_support"></a>Platform support</h3>
<div class="paragraph">
<p>The build system must have support for all of our platforms that we continually
test against as outlined by our platform support policy. These platforms are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Linux</p>
</li>
<li>
<p>Windows</p>
</li>
<li>
<p>macOS</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Furthermore, the build system should have support for the following platforms
that generally have somebody running test pipelines against regularly:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>AIX</p>
</li>
<li>
<p>FreeBSD</p>
</li>
<li>
<p>NetBSD</p>
</li>
<li>
<p>NonStop</p>
</li>
<li>
<p>OpenBSD</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The platforms which must be supported by the tool should be aligned with our
[platform support policy](platform-support.txt).</p>
</div>
</div>
<div class="sect2">
<h3 id="_auto_detection_of_supported_features"><a class="anchor" href="#_auto_detection_of_supported_features"></a>Auto-detection of supported features</h3>
<div class="paragraph">
<p>The build system must support auto-detection of features which are or aren&#8217;t
available on the current platform. Platform maintainers should not be required
to manually configure the complete build.</p>
</div>
<div class="paragraph">
<p>Auto-detection of the following items is considered to be important:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Check for the existence of headers.</p>
</li>
<li>
<p>Check for the existence of libraries.</p>
</li>
<li>
<p>Check for the existence of exectuables.</p>
</li>
<li>
<p>Check for the runtime behavior of specific functions.</p>
</li>
<li>
<p>Check for specific link order requirements when multiple libraries are
involved.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_ease_of_use"><a class="anchor" href="#_ease_of_use"></a>Ease of use</h3>
<div class="paragraph">
<p>The build system should be both easy to use and easy to extend. While this is
naturally a subjective metric it is likely not controversial to say that some
build systems are considerably harder to use than others.</p>
</div>
</div>
<div class="sect2">
<h3 id="_ide_support"><a class="anchor" href="#_ide_support"></a>IDE support</h3>
<div class="paragraph">
<p>The build system should integrate with well-known IDEs. Well-known IDEs include:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Microsoft Visual Studio</p>
</li>
<li>
<p>Visual Studio Code</p>
</li>
<li>
<p>Xcode</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>There are four levels of support:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Native integration into the IDE.</p>
</li>
<li>
<p>Integration into the IDE via a plugin.</p>
</li>
<li>
<p>Integration into the IDE via generating a project description with the build
system.</p>
</li>
<li>
<p>No integration.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Native integration is preferable, but integration via either a plugin or by
generating a project description via the build system are considered feasible
alternatives.</p>
</div>
<div class="paragraph">
<p>Another important distinction is the level of integration. There are two
features that one generally wants to have:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Integration of build targets.</p>
</li>
<li>
<p>Automatic setup of features like code completion with detected build
dependencies.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The first bullet point is the bare minimum, but is not sufficient to be
considered proper integration.</p>
</div>
</div>
<div class="sect2">
<h3 id="_out_of_tree_builds"><a class="anchor" href="#_out_of_tree_builds"></a>Out-of-tree builds</h3>
<div class="paragraph">
<p>The build system should support out-of-tree builds. Out-of-tree builds allow a
developer to configure multiple different build directories with different
configuration, e.g. one "debug" build and one "release" build.</p>
</div>
</div>
<div class="sect2">
<h3 id="_cross_platform_builds"><a class="anchor" href="#_cross_platform_builds"></a>Cross-platform builds</h3>
<div class="paragraph">
<p>The build system should support cross-platform builds, e.g. building for arm on
an x86-64 host.</p>
</div>
</div>
<div class="sect2">
<h3 id="_language_support"><a class="anchor" href="#_language_support"></a>Language support</h3>
<div class="paragraph">
<p>The following languages and toolchains are of relevance and should be supported
by the build system:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>C: the primary compiled language used by Git, must be supported. Relevant
toolchains are GCC, Clang and MSVC.</p>
</li>
<li>
<p>Rust: candidate as a second compiled lanugage, should be supported. Relevant
toolchains is the LLVM-based rustc.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Built-in support for the respective languages is preferred over support that
needs to be wired up manually to avoid unnecessary complexity. Native support
includes the following features:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Compiling objects.</p>
</li>
<li>
<p>Dependency tracking.</p>
</li>
<li>
<p>Detection of available features.</p>
</li>
<li>
<p>Discovery of relevant toolchains.</p>
</li>
<li>
<p>Linking libraries and executables.</p>
</li>
<li>
<p>Templating placeholders in scripts.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_test_integration"><a class="anchor" href="#_test_integration"></a>Test integration</h3>
<div class="paragraph">
<p>It should be possible to integrate tests into the build system such that it is
possible to build and test Git within the build system. Features which are nice
to have:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Track build-time dependencies for respective tests. Unit tests have
different requirements than integration tests.</p>
</li>
<li>
<p>Allow filtering of which tests to run.</p>
</li>
<li>
<p>Allow running tests such that utilities like <code>test_pause</code> or <code>debug</code> work.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_comparison"><a class="anchor" href="#_comparison"></a>Comparison</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The following list of build systems are considered:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>GNU Make</p>
</li>
<li>
<p>autoconf</p>
</li>
<li>
<p>CMake</p>
</li>
<li>
<p>Meson</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_gnu_make"><a class="anchor" href="#_gnu_make"></a>GNU Make</h3>
<div class="ulist">
<ul>
<li>
<p>Platform support: ubitquitous on all platforms, but not well-integrated into Windows.</p>
</li>
<li>
<p>Auto-detection: no built-in support for auto-detection of features.</p>
</li>
<li>
<p>Ease of use: easy to use, but discovering available options is hard. Makefile
rules can quickly get out of hand once reaching a certain scope.</p>
</li>
<li>
<p>IDE support: execution of Makefile targets is supported by many IDEs</p>
</li>
<li>
<p>Out-of-tree builds: supported in theory, not wired up in practice.</p>
</li>
<li>
<p>Cross-platform builds: supported in theory, not wired up in practice.</p>
</li>
<li>
<p>Language support:</p>
</li>
<li>
<p>C: Limited built-in support, many parts need to be wired up manually.</p>
</li>
<li>
<p>Rust: No built-in support, needs to be wired up manually.</p>
</li>
<li>
<p>Test integration: partially supported, many parts need to be wired up
manually.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_autoconf"><a class="anchor" href="#_autoconf"></a>autoconf</h3>
<div class="ulist">
<ul>
<li>
<p>Platform support: ubiquitous on all platforms, but not well-integrated into Windows.</p>
</li>
<li>
<p>Auto-detection: supported.</p>
</li>
<li>
<p>Ease of use: easy to use, discovering available options is comparatively
easy. The autoconf syntax is prohibitively hard to extend though due to its
complex set of interacting files and the hard-to-understand M4 language.</p>
</li>
<li>
<p>IDE support: no integration into IDEs at generation time. The generated
Makefiles have the same level of support as GNU Make.</p>
</li>
<li>
<p>Out-of-tree builds: supported in theory, not wired up in practice.</p>
</li>
<li>
<p>Cross-platform builds: supported.</p>
</li>
<li>
<p>Language support:</p>
</li>
<li>
<p>C: Limited built-in support, many parts need to be wired up manually.</p>
</li>
<li>
<p>Rust: No built-in support, needs to be wired up manually.</p>
</li>
<li>
<p>Test integration: partially supported, many parts need to be wired up
manually.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_cmake"><a class="anchor" href="#_cmake"></a>CMake</h3>
<div class="ulist">
<ul>
<li>
<p>Platform support: not as extensive as GNU Make or autoconf, but all major
platforms are supported.</p>
</li>
<li>
<p>AIX</p>
</li>
<li>
<p>Cygwin</p>
</li>
<li>
<p>FreeBSD</p>
</li>
<li>
<p>Linux</p>
</li>
<li>
<p>OpenBSD</p>
</li>
<li>
<p>Solaris</p>
</li>
<li>
<p>Windows</p>
</li>
<li>
<p>macOS</p>
</li>
<li>
<p>Ease of use: easy to use, discovering available options is not always
trivial. The scripting language used by CMake is somewhat cumbersome to use,
but extending CMake build instructions is doable.</p>
</li>
<li>
<p>IDE support: natively integrated into Microsoft Visual Studio. Can generate
project descriptions for Xcode. An extension is available for Visual Studio
Code. Many other IDEs have plugins for CMake.</p>
</li>
<li>
<p>Out-of-tree builds: supported.</p>
</li>
<li>
<p>Cross-platform builds: supported.</p>
</li>
<li>
<p>Language support:</p>
</li>
<li>
<p>C: Supported for GCC, Clang, MSVC and other toolchains.</p>
</li>
<li>
<p>Rust: No built-in support, needs to be wired up manually.</p>
</li>
<li>
<p>Test integration: supported, even though test dependencies are a bit
cumbersome to use via "test fixtures". Interactive test runs are not
supported.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_meson"><a class="anchor" href="#_meson"></a>Meson</h3>
<div class="ulist">
<ul>
<li>
<p>Platform: not as extensive as GNU Make or autoconf, but all major platforms
and some smaller ones are supported.</p>
</li>
<li>
<p>AIX</p>
</li>
<li>
<p>Cygwin</p>
</li>
<li>
<p>DragonflyBSD</p>
</li>
<li>
<p>FreeBSD</p>
</li>
<li>
<p>Haiku</p>
</li>
<li>
<p>Linux</p>
</li>
<li>
<p>NetBSD</p>
</li>
<li>
<p>OpenBSD</p>
</li>
<li>
<p>Solaris</p>
</li>
<li>
<p>Windows</p>
</li>
<li>
<p>macOS</p>
</li>
<li>
<p>Ease of use: easy to use, discovering available options is easy. The
scripting language is straight-forward to use.</p>
</li>
<li>
<p>IDE support: Supports generating build instructions for Xcode and Microsoft
Visual Studio, a plugin exists for Visual Studio Code.</p>
</li>
<li>
<p>Out-of-tree builds: supported.</p>
</li>
<li>
<p>Cross-platform builds: supported.</p>
</li>
<li>
<p>Language support:</p>
</li>
<li>
<p>C: Supported for GCC, Clang, MSVC and other toolchains.</p>
</li>
<li>
<p>Rust: Supported for rustc.</p>
</li>
<li>
<p>Test integration: supported. Interactive tests are supported starting with
Meson 1.5.0 via the <code>--interactive</code> flag.</p>
</li>
</ul>
</div>
</div>
</div>
</div>