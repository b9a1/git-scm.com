---
### DO NOT EDIT! Generated by script/update-docs.rb

category: manual
section: documentation
subsection: manual
title: Git - git-rerere Documentation
docname: git-rerere
lang: fr
aliases:
- "/docs/git-rerere/fr/index.html"
---
<div class="sect1">
<h2 id="_nom"><a class="anchor" href="#_nom"></a>NOM</h2>
<div class="sectionbody">
<div class="paragraph">
<p>git-rerere - Réutilise une résolution enregistrée de fusions conflictuelles</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_synopsis"><a class="anchor" href="#_synopsis"></a>SYNOPSIS</h2>
<div class="sectionbody">
<div class="verseblock">
<pre class="content"><em>git rererere</em> [clear | forget &lt;spec-de-chemin&gt;&#8230;&#8203; | diff | status | remaining | gc]</pre>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_description"><a class="anchor" href="#_description"></a>DESCRIPTION</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Dans un workflow employant des branches de sujet relativement longues, le développeur a parfois besoin de résoudre les mêmes conflits encore et encore jusqu&#8217;à ce que les branches de sujet soient faites (soit fusionnées à la branche "release" ou envoyées et acceptées en amont).</p>
</div>
<div class="paragraph">
<p>Cette commande aide le développeur dans ce processus en enregistrant des résultats d&#8217;autofusion en conflit et les résultats correspondants de la fusion manuelle initiale, et en appliquant des résolutions à la main précédemment enregistrées à leurs résultats d&#8217;autofusion correspondants.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Vous devez configurer la variable de configuration <code>rerere.enabled</code> pour activer cette commande.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_commandes"><a class="anchor" href="#_commandes"></a>COMMANDES</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Normalement, <em>git rerere</em> est exécuté sans arguments ou intervention utilisateur. Cependant, il a plusieurs commandes qui lui permettent d&#8217;interagir avec son état de fonctionnement.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-rerere-emclearem"> <a class="anchor" href="#git-rerere-emclearem"></a><em>clear</em> </dt>
<dd>
<p>Réinitialiser les meta-données utilisées par rerere si une résolution de fusion doit être annulée. Appeler <em>git am [--skip|--abort]</em> ou <em>git rebase [--skip|--abort]</em> invoque automatiquement cette commande.</p>
</dd>
<dt class="hdlist1" id="git-rerere-emforgetemltspc-de-chemingt"> <a class="anchor" href="#git-rerere-emforgetemltspc-de-chemingt"></a><em>forget</em> &lt;spéc-de-chemin&gt; </dt>
<dd>
<p>Réinitialiser les résolutions de conflit que rerere a enregistrées pour le conflit actuel dans ­<em>&lt;spéc-de-chemin&gt;</em>.</p>
</dd>
<dt class="hdlist1" id="git-rerere-emdiffem"> <a class="anchor" href="#git-rerere-emdiffem"></a><em>diff</em> </dt>
<dd>
<p>Afficher les diffs pour l&#8217;état actuel de la résolution. Il est utile de suivre ce qui a changé pendant que l&#8217;utilisateur résout les conflits. Des arguments supplémentaires sont transmis directement à la commande système <em>diff</em> installée dans PATH.</p>
</dd>
<dt class="hdlist1" id="git-rerere-emstatusem"> <a class="anchor" href="#git-rerere-emstatusem"></a><em>status</em> </dt>
<dd>
<p>Afficher les chemins avec des conflits dont la résolution de fusion sera enregistrée par rerere.</p>
</dd>
<dt class="hdlist1" id="git-rerere-emremainingem"> <a class="anchor" href="#git-rerere-emremainingem"></a><em>remaining</em> </dt>
<dd>
<p>Afficher les chemins avec des conflits qui n&#8217;ont pas été autorésolus par rerere. Cela inclut les chemins dont les résolutions ne peuvent pas être suivies par rerere, telles que des sous-modules en conflit.</p>
</dd>
<dt class="hdlist1" id="git-rerere-emgcem"> <a class="anchor" href="#git-rerere-emgcem"></a><em>gc</em> </dt>
<dd>
<p>Élaguer les enregistrements des fusions en conflit qui sont arrivées il y a longtemps. Par défaut, les conflits non résolus de plus de 15 jours et les conflits résolus de plus de 60 jours sont élagués. Ces valeurs par défaut sont contrôlées par les variables de configuration <code>gc.rerereUnresolved</code> et <code>gc.rerereResolved</code>.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_discussion"><a class="anchor" href="#_discussion"></a>DISCUSSION</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Lorsque votre branche de sujet modifie une zone de chevauchement que votre branche principale (ou amont) a touchée depuis que votre branche de sujet en a divergé, vous pouvez la tester avec le dernier master, même avant que votre branche de sujet soit prête à être poussée en amont :</p>
</div>
<div class="listingblock">
<div class="content">
<pre>              o---*---o thème
             /
    o---o---o---*---o---o master</pre>
</div>
</div>
<div class="paragraph">
<p>Pour un tel test, vous devez fusionner master et la branche thématique d&#8217;une manière ou d&#8217;une autre. Une façon de le faire est de tirer master dans la branche thématique :</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	$ git switch sujet
	$ git merge master

              o---*---o---+ sujet
             /           /
    o---o---o---*---o---o master</pre>
</div>
</div>
<div class="paragraph">
<p>Les commits marqués de <code>*</code> touchent la même zone dans le même fichier ; vous devez résoudre les conflits en créant le commit marqué <code>+</code>. Ensuite, vous pouvez tester le résultat pour vous assurer que votre travail en cours fonctionne toujours avec ce qui est dans le dernier master.</p>
</div>
<div class="paragraph">
<p>Après cette fusion de test, il y a deux façons de poursuivre votre travail sur la branche thématique. Le plus facile est de construire par dessus le commit de fusion test <code>+</code>, et lorsque votre travail dans la branche thématique est enfin prêt, fusionner la branche thématique dans master, et/ou demander à l&#8217;amont de tirer de vous. A ce moment-là, cependant, le master ou l&#8217;amont aurait pu être avancé depuis la fusion de test <code>+</code>, auquel cas le graphe final de commits ressemblerait à ceci :</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	$ git switch sujet
	$ git merge master
	$ ... travail sur la branche thématique et sur la branche master
	$ git switch master
	$ git merge sujet

              o---*---o---+---o---o sujet
             /           /         \
    o---o---o---*---o---o---o---o---+ master</pre>
</div>
</div>
<div class="paragraph">
<p>Lorsque votre branche thématique est au long cours, cependant, votre branche thématique finirait par avoir beaucoup de tels commits de "fusion depuis master" sur elle, qui encombreraient inutilement l&#8217;historique de développement. Les lecteurs de la liste de diffusion du noyau Linux se rappellent peut-être que Linus s&#8217;est plaint de fusions de tests trop fréquentes lorsqu&#8217;un mainteneur d&#8217;un sous-système a demandé de tirer d&#8217;une branche pleine de « fusions inutiles ».</p>
</div>
<div class="paragraph">
<p>Comme alternative, pour garder la branche thématique exempte de fusions d&#8217;essai, vous pourriez exploser la fusion d&#8217;essai, et continuer à construire sur le sommet de la branche avant la fusion d&#8217;essai :</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	$ git switch sujet
	$ git merge master
	$ git reset --hard HEAD^ ;# rembobine la fusion de test
	$ ... travail sur les deux branches thématique et master
	$ git switch master
	$ git merge sujet

              o---*---o-------o---o sujet
             /                     \
    o---o---o---*---o---o---o---o---+ master</pre>
</div>
</div>
<div class="paragraph">
<p>Cela ne laisserait qu’un seul commit de fusion lorsque votre branche thématique est enfin prête et fusionnée dans la branche master. Cette fusion vous obligerait à résoudre le conflit introduit par les commits marqués d’un <code>*</code>. Cependant, il s’agit souvent du même conflit que celui que vous avez résolu lors de la création de la fusion de test que vous avez explosée. <em>git rerere</em> vous aide à résoudre cette fusion finale conflictuelle en utilisant les informations de votre résolution à la main précédente.</p>
</div>
<div class="paragraph">
<p>Lancer la commande <em>git rerere</em> immédiatement après une autofusion conflictuelle enregistre les fichiers d&#8217;arbres de travail en conflit, avec les marqueurs de conflit habituels <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>, <code>=======</code> and <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>. Plus tard, après que vous avez fini de résoudre les conflits, exécuter <em>git rerere</em> à nouveau enregistrera l&#8217;état résolu de ces fichiers. Supposez que vous avez fait cela lorsque vous avez créé la fusion de test de master dans la branche thématique.</p>
</div>
<div class="paragraph">
<p>La prochaine fois, après avoir vu la même autofusion conflictuelle, lancer <code>git rerere</code> effectuera une fusion de trois points entre l&#8217;autofusion antérieure en conflit, la résolution manuelle antérieure et l&#8217;autofusion en conflit actuelle. Si cette fusion à trois points se résout proprement, le résultat est écrit à votre fichier d&#8217;arbre de travail, de sorte que vous n&#8217;avez pas à le résoudre manuellement. Notez que <em>git rerere</em> laisse le fichier index seul, donc vous devez toujours faire les vérifications de sanity finales avec <code>git diff</code> (ou <code>git diff -c</code>) et <code>git add</code> lorsque vous êtes satisfait.</p>
</div>
<div class="paragraph">
<p>Comme mesure de commodité, <em>git merge</em> invoque automatiquement <em>git rerere</em> à la sortie d&#8217;une autofusion ratée et <em>git rerere</em> enregistre la résolution manuelle lorsqu&#8217;il s&#8217;agit d&#8217;un nouveau conflit, ou réutilise la résolution manuelle antérieure sinon. <em>git commit</em> invoque également <em>git rerere</em> lors de la validation d&#8217;un résultat de fusion. Ce que cela signifie, c&#8217;est que vous n&#8217;avez rien de spécial à faire vous-même (à moins d&#8217;avoir désactivé la variable de configuration <code>rerere.enabled</code>).</p>
</div>
<div class="paragraph">
<p>Dans notre exemple, lorsque vous faites la fusion de test, la résolution manuelle est enregistrée, et elle sera réutilisée lorsque vous faites la fusion réelle plus tard avec les branches master et topic mises à jour, tant que la résolution enregistrée est toujours applicable.</p>
</div>
<div class="paragraph">
<p>Les enregistrement d&#8217;information <code>git rerere</code> sont également utilisées lors de l&#8217;exécution de <code>git rebase</code>. Après avoir fait exploser la fusion de test et continué le développement sur la branche thématique :</p>
</div>
<div class="listingblock">
<div class="content">
<pre>              o---*---o-------o---o sujet
             /
    o---o---o---*---o---o---o---o   master

	$ git rebase master sujet

				  o---*---o-------o---o sujet
				 /
    o---o---o---*---o---o---o---o   master</pre>
</div>
</div>
<div class="paragraph">
<p>vous pouvez lancer <code>git rebase master topic</code>, pour vous mettre à jour avant que votre sujet soit prêt à être envoyé en amont. Cela entraînerait un retour à une fusion à trois points et cela serait incompatible avec la fusion que vous avez résolue plus tôt. <em>git rerere</em> sera lancé par <em>git rebase</em> pour vous aider à résoudre ce conflit.</p>
</div>
<div class="paragraph">
<p>[NOTE] <em>git rerere</em> s&#8217;appuie sur les marqueurs de conflit dans le dossier pour détecter le conflit. Si le fichier contient déjà des lignes qui ressemblent aux lignes avec des marqueurs de conflit, « git rerere» peut ne pas enregistrer une résolution de conflit. Pour contourner cette limitation, on peut utiliser le réglage de la taille de la marqueur de conflit <code>conflict-marker-size</code> dans <a href='{{< relurl "docs/gitattributes/fr" >}}'>gitattributes[5]</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_git"><a class="anchor" href="#_git"></a>GIT</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Fait partie de la suite <a href='{{< relurl "docs/git/fr" >}}'>git[1]</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_traduction"><a class="anchor" href="#_traduction"></a>TRADUCTION</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Cette  page de manuel a été traduite par Jean-Noël Avila &lt;jn.avila AT free DOT fr&gt; et les membres du projet git-manpages-l10n. Veuillez signaler toute erreur de traduction par un rapport de bogue sur le site <a href="https://github.com/jnavila/git-manpages-l10n" class="bare">https://github.com/jnavila/git-manpages-l10n</a> .</p>
</div>
</div>
</div>